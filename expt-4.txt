import heapq

GOAL = ((1,2,3),
        (4,5,6),
        (7,8,0))  


def heuristic(state):
    distance = 0
    for i in range(3):
        for j in range(3):
            value = state[i][j]
            if value != 0:
                goal_x = (value - 1) // 3
                goal_y = (value - 1) % 3
                distance += abs(goal_x - i) + abs(goal_y - j)
    return distance


def find_zero(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def get_neighbors(state):
    neighbors = []
    x, y = find_zero(state)
    moves = [(1,0), (-1,0), (0,1), (0,-1)]
    
    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [list(row) for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append(tuple(tuple(row) for row in new_state))
    
    return neighbors


def astar(start):
    open_list = []
    heapq.heappush(open_list, (0 + heuristic(start), 0, start, []))
    closed_set = set()

    while open_list:
        f, g, current, path = heapq.heappop(open_list)

        if current == GOAL:
            return path + [current]

        if current in closed_set:
            continue

        closed_set.add(current)

        for neighbor in get_neighbors(current):
            if neighbor not in closed_set:
                heapq.heappush(open_list,
                               (g + 1 + heuristic(neighbor),
                                g + 1,
                                neighbor,
                                path + [current]))
    return None



INITIAL = ((1,0,2),
           (6,3,4),
           (7,5,8))


solution = astar(INITIAL)

if solution:
    print("Solution Found!\n")
    for step in solution:
        for row in step:
            print(row)
        print()
else:
    print("No Solution Found!")




output:
Solution Found!

(1, 0, 2)
(6, 3, 4)
(7, 5, 8)

(1, 2, 0)
(6, 3, 4)
(7, 5, 8)

(1, 2, 4)
(6, 3, 0)
(7, 5, 8)

(1, 2, 4)
(6, 0, 3)
(7, 5, 8)

(1, 2, 4)
(0, 6, 3)
(7, 5, 8)

(0, 2, 4)
(1, 6, 3)
(7, 5, 8)

(2, 0, 4)
(1, 6, 3)
(7, 5, 8)

(2, 4, 0)
(1, 6, 3)
(7, 5, 8)

(2, 4, 3)
(1, 6, 0)
(7, 5, 8)

(2, 4, 3)
(1, 0, 6)
(7, 5, 8)

(2, 0, 3)
(1, 4, 6)
(7, 5, 8)

(0, 2, 3)
(1, 4, 6)
(7, 5, 8)

(1, 2, 3)
(0, 4, 6)
(7, 5, 8)

(1, 2, 3)
(4, 0, 6)
(7, 5, 8)

(1, 2, 3)
(4, 5, 6)
(7, 0, 8)

(1, 2, 3)
(4, 5, 6)
(7, 8, 0)


=== Code Execution Successful ===










